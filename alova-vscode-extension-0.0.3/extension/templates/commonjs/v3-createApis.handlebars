{{{commentText}}}
const { Method } = require('alova');
const apiDefinitions = require('./apiDefinitions');
/**
 * @typedef {import('alova').AlovaGenerics} AlovaGenerics
 */
/**
 *
 * @param {(string|symbol)[]} array
 * @param {Alova<AlovaGenerics>} alovaInstance
 * @param {any} configMap
 * @returns {()=>void}
 */
const createFunctionalProxy = (array, alovaInstance, configMap) => {
  // create a new proxy instance
  return new Proxy(function () {}, {
    get(_, property) {
      // record the target property, so that it can get the completed accessing paths
      array.push(property);
      // always return a new proxy to continue recording accessing paths.
      return createFunctionalProxy(array, alovaInstance, configMap);
    },
    apply(_, __, [config]) {
      const apiItem = apiDefinitions[array.join('.')];
      if (!apiItem) {
        throw new Error(`the api path of \`${apiItem}\` is not found`);
      }
      const [method, url] = apiItem;
      const { pathParams, data } = config;
      const urlReplaced = url.replace(/\{([^}]+)\}/g, (_, key) => {
        const pathParam = pathParams[key];
        return pathParam;
      });
      delete config.pathParams;
      return new Method(method.toUpperCase(), alovaInstance, urlReplaced, config, data);
    }
  });
};
/**
 *
 * @param {Alova<AlovaGenerics>} alovaInstance
 * @param {any} configMap
 * @returns
 */
const createApis = (alovaInstance, configMap) =>{
  const Apis = new Proxy(
    {},
    {
      get(_, property) {
        return createFunctionalProxy([property], alovaInstance, configMap);
      }
    }
  );
  // 如果是全局定义
  globalThis.{{{global}}} = Apis;
  return Apis;
}
/**
 * @template T
 * @typedef {import('alova').AlovaMethodCreateConfig<typeof import('./index')['alovaInstance'] extends import('alova').Alova<infer AG> ? AG : any, any, T>} MethodConfig
 */
/**
 * @typedef {{#raw "{{ " }}{{/raw}}[P in keyof typeof import('./apiDefinitions')]?: MethodConfig<P extends `${infer Tag}.${infer Url}` ? Parameters<Parameters<{{{global}}}[Tag][Url]>[0]['transform']>[0] : any>{{#raw " }}" }}{{/raw}} MethodsConfigMap
 */
/**
 * @template {MethodsConfigMap} Config
 * @param {Config} config
 */
const withConfigType = config => config;

module.exports = {
  createApis,
  withConfigType
};

